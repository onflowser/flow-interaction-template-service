{
    "f_type": "InteractionTemplate",
    "f_version": "1.0.0",
    "id": "f9486a4b24d8606590855ffb7c433b023101d329e9a8c1fb8d48a4c37667586e",
    "data": {
        "type": "InteractionTemplate",
        "interface": "",
        "messages": {
            "title": {
                "i18n": {
                    "en-US": "MikoSeaMarket Create listing"
                }
            },
            "description": {
                "i18n": {
                    "en-US": "Create listing"
                }
            }
        },
        "cadence": "// createListingV1.1\nimport MikoSeaMarket from 0xMIKOSEA_MARKET_ADDRESS\nimport MIKOSEANFT from 0xMIKOSEA_MIKOSEANFT_ADDRESS\nimport MIKOSEANFTV2 from 0xMIKOSEA_MIKOSEANFTV2_ADDRESS\nimport FungibleToken from 0xFUNGIBLE_TOKEN_ADDRESS\nimport NonFungibleToken from 0xNON_FUNGIBLE_TOKEN_ADDRESS\nimport MetadataViews from 0xMETADATA_VIEWS_ADDRESS\n\npub fun getNftV2Metadata(addr: Address, nftID: UInt64): {String:String} {\n    let account = getAccount(addr)\n    let collectioncap = account.getCapability<&{MIKOSEANFTV2.CollectionPublic}>(MIKOSEANFTV2.CollectionPublicPath)\n    let collectionRef = collectioncap.borrow() ?? panic(\"Could not borrow collection capability\")\n\n    let nft = collectionRef.borrowMIKOSEANFTV2(id: nftID)\n    if nft == nil {\n        return {}\n    }\n    let nftAs = nft!\n    return nftAs.getMetadata()\n}\n\npub fun validateNftExpeiredDate(nftType: String, address: Address, nftID: UInt64) {\n    if nftType == \"mikoseav2\" {\n        let metadata = getNftV2Metadata(addr: address, nftID: nftID)\n        let start_at_unix = UInt64.fromString(metadata[\"start_at\"] ?? \"\")\n        let end_at_unix = UInt64.fromString(metadata[\"end_at\"] ?? \"\")\n        let next_expired_at_unix = UInt64.fromString(metadata[\"next_expired_at\"] ?? \"\")\n        let currentTime = getCurrentBlock().timestamp\n\n        if start_at_unix != nil {\n            if UFix64(start_at_unix!) > currentTime {\n                panic(\"NFT_START_AT_IS_INVALID\")\n            }\n        }\n        if end_at_unix != nil {\n            if UFix64(end_at_unix!) < currentTime {\n                panic(\"NFT_END_AT_IS_INVALID\")\n            }\n        }\n        if next_expired_at_unix != nil {\n            if UFix64(next_expired_at_unix!) < currentTime {\n                panic(\"NFT_NEXT_EXPIRED_AT_IS_INVALID\")\n            }\n        }\n    }\n}\n\npub fun getRoyaltiesV1(address: Address, nftID: UInt64): MetadataViews.Royalties {\n    if !MIKOSEANFT.checkCollection(address) {\n        panic(\"ACCOUNT_NOT_SETUP\")\n    }\n\n    // check holder holds NFT\n    let nftData = MIKOSEANFT.fetch(_from: address, itemId:nftID) ?? panic(\"NFT_NOT_FOUND\")\n    let projectId = nftData.data.projectId\n\n    let projectCreatorFee = MIKOSEANFT.getProjectCreatorFee(projectId: projectId) ?? 0.1\n    let projectCreatorAddress = MIKOSEANFT.getProjectCreatorAddress(projectId: projectId)!\n    let platfromFee = MIKOSEANFT.getProjectPlatformFee(projectId: projectId) ?? 0.05\n    return MetadataViews.Royalties([\n        MetadataViews.Royalty(\n            receiver: getAccount(projectCreatorAddress).getCapability<&AnyResource{FungibleToken.Receiver}>(MIKOSEANFT.CollectionPublicPath),\n            cut: projectCreatorFee,\n            description: \"Creator fee\"\n        ),\n        MetadataViews.Royalty(\n            receiver: getAccount(MikoSeaMarket.getAdminAddress()).getCapability<&AnyResource{FungibleToken.Receiver}>(MIKOSEANFT.CollectionPublicPath),\n            cut: platfromFee,\n            description: \"Platform fee\"\n        )\n    ])\n}\n\npub fun getRoyaltiesV2(address: Address, nftID: UInt64): MetadataViews.Royalties {\n    let collectionRef = getAccount(address).getCapability<&{MIKOSEANFTV2.CollectionPublic}>(MIKOSEANFTV2.CollectionPublicPath).borrow() ?? panic(\"ACCOUNT_NOT_SETUP\")\n    let nft = collectionRef.borrowMIKOSEANFTV2(id: nftID) ?? panic(\"NFT_NOT_FOUND\")\n    return nft.getRoyaltiesMarket()\n}\n\ntransaction(nftID: UInt64, salePrice: UFix64, nftversion: String) {\n    let holderCap: Capability<&AnyResource{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>\n    let storefrontRef: &MikoSeaMarket.Storefront\n    let royalties: MetadataViews.Royalties\n    let nftType: Type\n\n    prepare(account: AuthAccount) {\n        pre {\n            nftversion == \"mikosea\" || nftversion == \"mikoseav2\": \"nftversion must be mikosea or mikoseav2\".concat(\", got \").concat(nftversion)\n        }\n\n        // setup account\n        // for MIKOSAENFTV2\n        if account.borrow<&MIKOSEANFTV2.Collection>(from: MIKOSEANFTV2.CollectionStoragePath) == nil {\n            let collection <- MIKOSEANFTV2.createEmptyCollection()\n            account.save(<-collection, to: MIKOSEANFTV2.CollectionStoragePath)\n        }\n        if (account.getCapability<&MIKOSEANFTV2.Collection{MIKOSEANFTV2.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(MIKOSEANFTV2.CollectionPublicPath).borrow() == nil) {\n            account.unlink(MIKOSEANFTV2.CollectionPublicPath)\n            account.link<&MIKOSEANFTV2.Collection{MIKOSEANFTV2.CollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(MIKOSEANFTV2.CollectionPublicPath, target: MIKOSEANFTV2.CollectionStoragePath)\n        }\n        // for MIKOSAENFT\n        if account.borrow<&MIKOSEANFT.Collection>(from: MIKOSEANFT.CollectionStoragePath) == nil {\n            let collection <- MIKOSEANFT.createEmptyCollection()\n            account.save(<-collection, to: MIKOSEANFT.CollectionStoragePath)\n        }\n        if (account.getCapability<&MIKOSEANFT.Collection{MIKOSEANFT.MikoSeaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(MIKOSEANFT.CollectionPublicPath).borrow() == nil) {\n            account.unlink(MIKOSEANFT.CollectionPublicPath)\n            account.link<&MIKOSEANFT.Collection{MIKOSEANFT.MikoSeaCollectionPublic,NonFungibleToken.CollectionPublic,NonFungibleToken.Receiver,MetadataViews.ResolverCollection}>(MIKOSEANFT.CollectionPublicPath, target: MIKOSEANFT.CollectionStoragePath)\n        }\n\n        // check and create storefront\n        if let storefrontRef = account.borrow<&MikoSeaMarket.Storefront>(from: MikoSeaMarket.MarketStoragePath) {\n            self.storefrontRef = storefrontRef\n        } else {\n            let storefront <- MikoSeaMarket.createStorefront()\n            let storefrontRef = &storefront as &MikoSeaMarket.Storefront\n            account.save(<-storefront, to: MikoSeaMarket.MarketStoragePath)\n            account.link<&MikoSeaMarket.Storefront{MikoSeaMarket.StorefrontPublic}>(MikoSeaMarket.MarketPublicPath, target: MikoSeaMarket.MarketStoragePath)\n            self.storefrontRef = storefrontRef\n        }\n\n        // validate nft\n        validateNftExpeiredDate(nftType: nftversion, address: account.address, nftID: nftID)\n\n        if nftversion == \"mikosea\" {\n            // get royalties\n            self.royalties = getRoyaltiesV1(address: account.address, nftID: nftID)\n\n            // link private collection\n            let MIKOSEANFTPrivatePath = /private/MIKOSEANFTCollection\n            if !account.getCapability<&MIKOSEANFT.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTPrivatePath).check() {\n                account.link<&MIKOSEANFT.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTPrivatePath, target: MIKOSEANFT.CollectionStoragePath)\n            }\n            self.holderCap = account.getCapability<&MIKOSEANFT.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTPrivatePath)\n\n\n            // get nft type\n            self.nftType = Type<@MIKOSEANFT.NFT>()\n        } else {\n            // get royalties\n            self.royalties = getRoyaltiesV2(address: account.address, nftID: nftID)\n\n            // link private collection\n            let MIKOSEANFTV2PrivatePath = /private/MIKOSEANFTV2Collection\n            if !account.getCapability<&MIKOSEANFTV2.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTV2PrivatePath).check() {\n                account.link<&MIKOSEANFTV2.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTV2PrivatePath, target: MIKOSEANFTV2.CollectionStoragePath)\n            }\n            self.holderCap = account.getCapability<&MIKOSEANFTV2.Collection{NonFungibleToken.Provider, NonFungibleToken.CollectionPublic}>(MIKOSEANFTV2PrivatePath)\n\n\n            // get nft type\n            self.nftType = Type<@MIKOSEANFTV2.NFT>()\n\n            let holder = account.borrow<&MIKOSEANFTV2.Collection>(from: MIKOSEANFTV2.CollectionStoragePath)!\n            holder.setInMarket(nftID: nftID, value: true)\n        }\n    }\n\n    execute {\n        self.storefrontRef.createOrder(\n            nftType: self.nftType,\n            nftID: nftID,\n            holderCap: self.holderCap,\n            salePrice: salePrice,\n            royalties: self.royalties,\n            metadata: {}\n        )\n    }\n}\n",
        "dependencies": {
            "0xMIKOSEA_MARKET_ADDRESS": {
                "MikoSeaMarket": {
                    "testnet": {
                        "address": "0x713306ac51ac7ddb",
                        "contract": "MikoSeaMarket",
                        "fq_address": "A.0x713306ac51ac7ddb.MikoSeaMarket",
                        "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                        "pin_block_height": 138900314
                    }
                }
            },
            "0xMIKOSEA_MIKOSEANFT_ADDRESS": {
                "MIKOSEANFT": {
                    "testnet": {
                        "address": "0x713306ac51ac7ddb",
                        "contract": "MIKOSEANFT",
                        "fq_address": "A.0x713306ac51ac7ddb.MIKOSEANFT",
                        "pin": "9524cc8b5eb8bb8f7d8cf4ee3c65374cafa55921d31d6f72ce08d1c4da8aad57",
                        "pin_block_height": 138900430
                    }
                }
            },
            "0xMIKOSEA_MIKOSEANFTV2_ADDRESS": {
                "MIKOSEANFTV2": {
                    "testnet": {
                        "address": "0x713306ac51ac7ddb",
                        "contract": "MIKOSEANFTV2",
                        "fq_address": "A.0x713306ac51ac7ddb.MIKOSEANFTV2",
                        "pin": "bfeedef4b4548a7bab30ecf31c97eb781c67f2414b4913d5bb19e58aeebbc515",
                        "pin_block_height": 138900589
                    }
                }
            },
            "0xFUNGIBLE_TOKEN_ADDRESS": {
                "FungibleToken": {
                    "testnet": {
                        "address": "0x9a0766d93b6608b7",
                        "contract": "FungibleToken",
                        "fq_address": "A.0x9a0766d93b6608b7.FungibleToken",
                        "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                        "pin_block_height": 138900591
                    }
                }
            },
            "0xNON_FUNGIBLE_TOKEN_ADDRESS": {
                "NonFungibleToken": {
                    "testnet": {
                        "address": "0x631e88ae7f1d7c20",
                        "contract": "NonFungibleToken",
                        "fq_address": "A.0x631e88ae7f1d7c20.NonFungibleToken",
                        "pin": "83c9e3d61d3b5ebf24356a9f17b5b57b12d6d56547abc73e05f820a0ae7d9cf5",
                        "pin_block_height": 138900612
                    }
                }
            },
            "0xMETADATA_VIEWS_ADDRESS": {
                "MetadataViews": {
                    "testnet": {
                        "address": "0x631e88ae7f1d7c20",
                        "contract": "MetadataViews",
                        "fq_address": "A.0x631e88ae7f1d7c20.MetadataViews",
                        "pin": "ba061d95016d5506e9f5d1afda15d82eb066aa8b0552e8b26dc7950fa5714d51",
                        "pin_block_height": 138900640
                    }
                }
            }
        },
        "arguments": {
            "addr": {
                "index": 0,
                "type": "Address",
                "messages": {}
            },
            "nftID": {
                "index": 1,
                "type": "UInt64",
                "messages": {}
            }
        }
    }
}